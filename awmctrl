#! /usr/bin/python3
import collections
import logging
import os
import re
import subprocess
import sys
import time
import yaml


class Geometry(collections.namedtuple('Geometry', ('w', 'h'))):
    def __str__(self):
        return f"{self.w}x{self.h}"
Position = collections.namedtuple('Position', ('x', 'y'))
Display = collections.namedtuple('Display', ('geometry', 'position'))
Window = collections.namedtuple('Window', ('did', 'title', 'geometry'))

def get_geometry():
    # This returns the current geometry, and will center the laptop display under the other one (if any)
    #
    # Clearly, there are a few assumptions here:
    # - the laptop is situated under the other monitor
    # - there is at most a single monitor in addition to the laptop
    xrandr = subprocess.check_output(('xrandr', '--current'))
    displays = {}
    x, y = 0, 0
    primary = None
    for line in xrandr.decode(encoding='UTF-8').splitlines():
        m = re.match(r'^(?P<name>\S+) connected (?P<pri>primary )?'
                     r'(?:(?P<w>\d+)x(?P<h>\d+)\+(?P<x>\d+)\+(?P<y>\d+))',
                     line)
        if not m:
            continue
        if m.group('pri'):
            name = 'laptop'
            primary = m.group('name')
            x = int(m.group('x'))
            y = int(m.group('y'))
        else:
            name = 'monitor'
        displays[name] = Display(geometry=Geometry(w=int(m.group('w')), h=int(m.group('h'))),
                                 position=Position(x=int(m.group('x')), y=int(m.group('y'))))
    if len(displays) == 2:
        dx = (displays['monitor'].geometry.w - displays['laptop'].geometry.w) // 2
        dy = displays['monitor'].geometry.h
        if x != dx or y != dy:
            logging.info(f"centering primary display: {(x, y)} -> {(dx, dy)}")
            subprocess.call(('xrandr', '--output', primary, '--pos', f"{dx}x{dy}"),
                            stdout=sys.stdout, stderr=sys.stderr)
    if 'monitor' in displays:
        return Geometry(w=displays['monitor'].geometry.w,
                        h=sum(map(lambda x: x.geometry.h, displays.values()))), displays
    else:
        return displays['laptop'], displays

def get_config():
    config = yaml.load(open(config_path, 'r'), Loader=yaml.SafeLoader)
    for setup in ('single', 'multi'):
        rules = config.get(setup, {}).get('rules', [])
        for i in range(len(rules)):
            rules[i]['title'] = re.compile(rules[i]['title'])
            if 'screen' in rules[i]:
                rules[i]['screen'] = f"{rules[i]['screen']}"
            if 'geometry' in rules[i]:
                m = re.match('(?:(?P<w>\d+)x(?P<h>\d+))?(?:(?P<x>[+-]\d+)(?P<y>[+-]\d+))?',
                             rules[i]['geometry'])
                if not m:
                    raise ValueError(f"invalid geometry: {rules[i]['geometry']}")
                rules[i]['geometry'] = Display(geometry=Geometry(w=m.group('w'), h=m.group('h')),
                                               position=Position(x=m.group('x'), y=m.group('y')))
    return config


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(levelname).1s %(asctime).19s %(message)s')
    config_path = os.path.join(os.environ['HOME'], '.awmctrl')
    last = None
    config = None
    positions = {}
    while True:
        try:
            config = get_config()
        except Exception as e:
            if config is None:
                raise e
            logging.warning(f"invalid configuration: {e}")

        try:
            geometry, displays = get_geometry()
            if last != geometry and geometry in positions:
                move = True
            else:
                move = False
            if last != geometry:
                if last:
                    logging.info(f"new setup: {last} -> {geometry} {move=}")
                else:
                    logging.info(f"initial setup: {geometry}")

            new = {}
            wp = subprocess.check_output(('wmctrl', '-lG'))
            for window in wp.decode(encoding='UTF-8').splitlines():
                m = re.match(r'(?P<wid>0x[0-9a-f]+) +(?P<did>-?\d+) '
                             r'(?P<x>-?\d+)\s+(?P<y>-?\d+)\s+(?P<w>\d+)\s+(?P<h>\d+)\s+'
                             r'\S+\s+(?P<title>.+)', window)
                if m.group('did') == '-1': continue
                if move:
                    # move the windows back to where they were
                    if m.group('wid') in positions[geometry]:
                        window = positions[geometry][m.group('wid')]
                        if m.group('did') != window.did:
                            subprocess.call(('wmctrl', '-i', '-r', m.group('wid'), '-t', window.did),
                                            stdout=sys.stdout, stderr=sys.stderr)
                        subprocess.call(('wmctrl', '-i', '-r', m.group('wid'), '-e', window.geometry),
                                        stdout=sys.stdout, stderr=sys.stderr)
                    else:
                        logging.info(f"not moving new window '{m.group('title')}'")
                else:
                    new[m.group('wid')] = Window(did=m.group('did'),
                                                 title=m.group('title'),
                                                 geometry=','.join(('0', m.group('x'), m.group('y'), m.group('w'), m.group('h'))))

            if geometry not in positions:
                logging.info('applying configured rules')
                if len(displays) == 1:
                    rules = config.get('single', {}).get('rules', [])
                else:
                    rules = config.get('multi', {}).get('rules', [])
                for wid, window in new.items():
                    for rule in rules:
                        if rule.get('when', str(geometry)) != str(geometry):
                            continue
                        if not rule['title'].search(window.title):
                            continue
                        if window.did != rule.get('screen', window.did):
                            logging.info(f"moving '{window.title}' to screen {rule['screen']}")
                            subprocess.call(('wmctrl', '-i', '-r', wid, '-t', rule['screen']),
                                            stdout=sys.stdout, stderr=sys.stderr)
                        if display := displays.get(rule.get('maximize')):
                            x, y = display.position.x, display.position.y
                            w, h = display.geometry.w, display.geometry.h
                            if rule['maximize'] == 'laptop':
                                y += 14  # shouldn't be hard coded, but I'm lazy
                                h -= 14
                            if window.title.endswith('Google Chrome'):
                                # Chrome window weirdness
                                x -= 16
                                w += 32
                                h += 32
                            mvarg = ','.join(map(lambda x: str(x), ('0', x, y, w, h)))
                            if mvarg != window.geometry:
                                logging.info(f"maximizing '{window.title}' on {rule['maximize']}")
                                subprocess.call(('wmctrl', '-i', '-r', wid, '-e', mvarg),
                                                stdout=sys.stdout, stderr=sys.stderr)
                        elif (spec := rule.get('geometry')) \
                             and (display := displays.get(rule.get('display'))):
                            w, h = map(lambda x: int(x), window.geometry.split(',')[-2:])
                            if spec.geometry.w:
                                w, h = int(spec.geometry.w), int(spec.geometry.h)
                            if spec.position.x:
                                x = display.position.x + int(spec.position.x)
                                y = display.position.y + int(spec.position.y)
                                if spec.position.x[0] == '-':
                                    x += display.geometry.w - w
                                    if window.title.endswith('Google Chrome'):
                                        # Chrome window weirdness
                                        x += 32
                                elif window.title.endswith('Google Chrome'):
                                    # Chrome window weirdness
                                    x -= 16
                                if spec.position.y[0] == '-':
                                    y += display.geometry.h - h
                                    if window.title.endswith('Google Chrome'):
                                        # Chrome window weirdness
                                        y += 32
                                elif window.title.endswith('Google Chrome'):
                                    # Chrome window weirdness
                                    y -= 16
                            else:
                                x, y = map(lambda x: int(x), window.geometry.split(',')[1:3])
                            mvarg = ','.join(map(lambda x: str(x), ('0', x, y, w, h)))
                            if mvarg != window.geometry:
                                logging.info(f"moving '{window.title}' on {rule['display']} from {window.geometry[2:]} to {mvarg[2:]}")
                                subprocess.call(('wmctrl', '-i', '-r', wid, '-e', mvarg),
                                                stdout=sys.stdout, stderr=sys.stderr)
                        break

            now, _ = get_geometry()
            if now == geometry:
                last = geometry
                positions[last] = new
            else:
                logging.warning(f"geometry changed ({last} -> {now}) during {move=}, restarting update")
                continue
        except Exception as e:
            logging.error(f"error: {e}", exc_info=True)
        then = time.time()
        time.sleep(2)
        now = time.time()
        if now - then > 3:
            logging.info(f"took a {now - then:.0f} second nap")
